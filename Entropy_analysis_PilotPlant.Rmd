---
title: "Entropy Analysis for MLA data"
author: "Edgar Schach, Raimon Tolosana Delgado"
date: "2024-05-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Load Packages for the calculations

```{r Load Packages}
library(tidyverse)
library(RColorBrewer)
library(compositions)
library(future)
library(furrr)
library(parallel)
library(parallelly)
library(future.apply)
library(microbenchmark)
library(foreach)
library(doFuture)
library(tidyverse)
library(broom)
library(readxl)
library(ggpubr)   

source(file = "./functions_paper2.R")
source("./mlaXMLSession.R")
source("./Entropy_Functions-toSubmit.R")
# install.packages("remotes")
# remotes::install_github("teunbrand/ggh4x")

```
## Setting Colors and Factor Levels for Plots

For plots in ggplot, color values can set once, to have consistent colors throughout the graphs. Further, factors and their levels are used to 
change the order of facets,legends ect. in ggplot. Once defined they can be recycled as well. 

```{r}
cols_component.dist <- brewer.pal(n = 5, name = "Blues")[2:5]
names(cols_component.dist) <- c("c0j0","cij0","c0jk","cijk")

cols_particle.dist <- brewer.pal(n = 4, name = "Greens")
names(cols_particle.dist) <- c("p00k","p0jk","pi0k","pijk")

cols_partition.vec <- brewer.pal(n = 4, name = "Reds")
names(cols_partition.vec) <- c("ti00","ti0k","tij0","tijk")

entropy_colors <- c(cols_component.dist,
                    cols_particle.dist,
                    cols_partition.vec)

type.levels <- c("ti00","ti0k","tij0","tijk", # partitions
                 "p00k","p0jk","pi0k","pijk" ,# distributions
                 "c0j0","cij0","c0jk","cijk") # compositions

sample_lvl <- c("Feed","Recal Feed","Magnetic","Non-magnetic","Product","Coarse","Fine")
machine_lvl <- c("Sieve","Magnetic separator","Mill")
machine.nms <- c("Sieve"="Sieve","spiral Con."="Spiral Concentrator","Mill1"="Mill1","Magnetic Con."="Magnetic Separator","Sulfide Flotation"="Sulphide-Flotation","Screw Class."="Screw-Classifier","Hydrocyclone"="Hydro-Cyclone","Shaking Table"="Shaking-Table","Mill2"="Mill2")

machine_labeller <- function(variable,value){
  return(machine.nms[value])
}

machine.lvl.extended <- machine.nms
names(machine.lvl.extended) <-  NULL

```


## Data Preparation

For the calculation of the entropies for each sample point, an excel sheet provides the information for each machine, including which sample points belong to the feed stage and which points in the pilot plant belong to the product stage.Further, the file also contains the balanced mass streams. 
The MLA-data is saved in a R-file with the name MLA_Particles.RData. An appropriate grouping for the over 81 mineral phases detected in the MLA data is given as XML file. 

```{r data preparation}
#Loading Particle MLA Data 
load("./MLA_Particles.RData")

#Loading machine data from a csv file. 
machines <-  read_delim("Machines_MLA.csv", delim = ";", 
    escape_double = FALSE, locale = locale(decimal_mark = ",", 
        grouping_mark = "."), trim_ws = TRUE)

machine_levels <- unique(machines$machine) 
#Transform machines into a list format

machines.transform <- function(machine){
  feed_stage <- machine %>% filter(stage == "Feed") %>% select(sample) %>% unlist()
  product_stage <- machine %>% filter(stage == "Product") %>% 
    select(sample) %>% unlist()
  weights_feed <- machine %>% filter(stage == "Feed") %>% select("weights")  %>% unlist() %>% clo()
  weights_products <- machine %>% filter(stage == "Product") %>% select("weights")  %>% unlist() %>% clo()
  weights <- c(weights_feed,weights_products)
  names(weights) <- machine$sample
  res <- list(feed_stage = feed_stage,
              product_stage = product_stage,
              weights = weights)
  return(res)
}

machines <- machines %>% split(f = .$machine) %>% map(machines.transform)

```

In a next step we apply the grouping to the MLA data and fix some issues regarding the names of the minerals and there abundance in all samples.
Mineral Groupings can be applied by matrix multiplication of a particle matrix (rows = particles, columns = phases) with the grouping matrix (gm). For a meaningful entropy analysis for a certain separation problem it is important to apply a meaningful grouping.  

```{r General mineral grouping}
# Applying a general grouping and obtaining the particle data. 

mlaSetXMLGroupsAndPalette("./Mineral_grouping.xml") # pay attention to the right path
aux = options()$mlaGrouping
rownames(aux$groupingMatrix)[25]  <-"Tourmaline (Schorl-Dravite_Na-Mg)"
options(mlaGrouping = aux)

gm <- aux$groupingMatrix
gm <- as.data.frame(t(gm))
gm[,"Mn-Silicate"] <- c(1,rep(0,times = 11))
gm <- as.data.frame(t(gm))
write.csv(gm,file = "grouping_matrix.csv")
gm <- read.delim("./grouping_matrix_MLA.CSV",)
gm <- read_delim("grouping_matrix_MLA.CSV", 
    delim = ";", escape_double = FALSE, trim_ws = TRUE)
gm <- data.frame(gm)
rownames(gm) <- gm$Column1
gm <- gm %>% select(-Column1)

concentration_names <- c("Stream","Mass-Flowrate","Quartz","Feldspar","Garnet","Epidote","Amphibole","Pyroxene","Chlorite","Mica","Cassiterite","Iron-Oxide","Fluorite","Carbonate","Sphalerite","Fe-Sulfides","Cu-Sulfides","Arsenopyrite","Others")

concentrations <- read_delim("mass_flows_and_concentrations.CSV", 
    delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", 
        grouping_mark = "."), trim_ws = TRUE) 
nms_streams <- concentrations$Stream
colnames(concentrations) <- concentration_names
concentrations <- concentrations %>% select(-c("Stream","Mass-Flowrate")) %>% as.data.frame()
row.names(concentrations) <-  nms_streams



mineral_masses <-   lapply(SamplesMLA, function(x){
  res <- as.data.frame(as.matrix(x$minMassComp) %*% as.matrix(gm[colnames(x$minMassComp),]))
  colnames(res) <- colnames(concentrations)
  return(res)
})

part_dat <- lapply(mineral_masses,function(x)select(x,-contains("Tourmaline")))

of.interest <- c("Cassiterite","Iron-Oxide","Cu-Sulfides","Arsenopyrite","Sphalerite")

group_minerals <- function(x){
  rest <- x %>% 
    select(-any_of(of.interest)) %>% 
    rowSums()
  x <- x %>%
    select(any_of(of.interest)) %>% 
    mutate(Rest = rest)
  return(x)
}

ECD <- map(SamplesMLA,~sqrt(4*.x$geomProps$ParticleArea/pi))
part_dat_grouped <- map(part_dat,group_minerals)
part_dat_grouped <- map(part_dat_grouped,~.x/100)
part_dat_grouped <- map2(part_dat_grouped,ECD,~t(sweep(t(.x),2,.y*2/3*10^(-12),"*")))
grouped_concentrations <- group_minerals(concentrations)
corrected_concentrations <- grouped_concentrations %>% select(-Rest) %>% clo

```


## Particle Number Calculations

The measured MLA samples do not scale with the actual mass streams of the sample points in the pilot plant. Therefore, they only resamble arbitary numbers of particles. As the entropy is dependend on the particle number in a sample, they have to be rescaled to a meaningful particle number. The distributional information given by the MLA samples can be considered concise. Therefore, the number of particles representing one gram of material can be calculated from each sample. This is done by the following steps: 

- the area of a particle is transformed into a circular area by calculation of the equivalent circle diameter (ECD)
- The particle volume is calculated from the circular area.
- The volume weighted mean diameter for the sample is calculated
- The volume weighted mean density for the sample is calculated. 
- The mean volume is calculated from the mean diameter
- The mean mass is caluclated from the mean volume and the mean density
- The particle number is given by 1g/ mean mass

```{r}
particle_number_calculation <- function(MLA_data,th.mass = 1){
  relevants <- function(x) data.frame(ECD = sqrt(4*x$geomProps$ParticleArea/pi),
                                      mass = x$geomProps$Mass/100)
  rel <- relevants(MLA_data)
  masses <- rel %>% mutate(vol_mass = 2/3*mass*ECD*10^(-12)) %>% select(vol_mass) %>% unlist() #particle mass in g
  N <- th.mass/mean(masses)
  return(N)
}


 cal_vol_masses <- function(x) {
   relevants <- function(x) data.frame(ECD = sqrt(4*x$geomProps$ParticleArea/pi),
                                      mass_area = x$geomProps$Mass/100)
 rel <- relevants(x)
 res <- rel %>% mutate(mass_vol = mass_area*2/3*ECD*10^(-12))  
 return(res)
 }
 
vol_masses <- map(SamplesMLA,cal_vol_masses)

particle.numbers <- sapply(SamplesMLA,particle_number_calculation)


num.res <- data.frame(Sample = names(particle.numbers),
                 particle.numbers = particle.numbers)

g <- ggplot(num.res, aes(Sample,log10(particle.numbers))) +
  geom_bar(stat = "identity") +
  theme_bw() +
  labs(x = "sample point", y = "log 10 particle numbers")
print(g)
number.differences <- 100000-particle.numbers*10
ggsave(filename = "part.numbers.new.png",device = "png",width = 15, height = 10, units = "cm")

```


## Calculation of entropy values for each sample point for 100 000 particles 

The entropy of a sample is dependend on the numbers of particles in a sample. Thereby it is important to observe enough particles to obtain a representative property distribution of the sample and on the other hand only take as much particles as needed into consideration to avoid running into memory issues during computation which can easily lead to very long computation times. A good compromise is given for a particle number of 100 000 particles which can be further rescaled to any desireable particle number. 
For the calculation we first define a function that calculates the entropy aggregations of interest for one batch and rescales the particle entropy to the value $H1$.

```{r function for the normalized entropy calculation for one batch}
batch.entropy.norm <- function(part.dat){
  # Calculating Extensive Properties for Feed Batch:
  
  N000 <- sum(part.dat)
  N0j0 <- colSums(part.dat)
  N00k <- rowSums(part.dat)
  N0jk <- part.dat
  
  #Calculating Extensive Properties for Product Batch(es)
  
  #Intensive Größen für Feed:   
  
  c0j0 <- colSums(part.dat)/sum(part.dat) # composition of batchstage
  c0jk <- N0jk/N00k # integrowth of batchstage
  p00k <- N00k/N000 # mass distribution in batchstage
  p0jk <- sweep(N0jk,2,N0j0,"/") #component distribution in batchstage
  
  #Entropy Calculation for Feed####
  #c0j0.p0jk
  
  ent_c0j0 <- .entropy(c0j0) #- log(length(c0j0))
  ent_p0jk <- apply(p0jk,2,.entropy)
  ent_p0jk <- ent_p0jk - log(length(p00k))
  ent_p0jk <- c0j0 %*% ent_p0jk
  
  #p00k.cojk
  
  ent_p00k <- .entropy(p00k)
  ent_p00k <- ent_p00k - log(length(p00k))
  ent_c0jk <- apply(c0jk,1,.entropy)# - log(length(c0j0))
  ent_c0jk <- p00k %*% ent_c0jk
  
  c0j0.p0jk <- c(c0j0 = ent_c0j0, p0jk = ent_p0jk)
  p00k.c0jk <- c(p00k = ent_p00k, c0jk = ent_c0jk)
  
  res_batch <- list(c0j0.p0jk = c0j0.p0jk,
                    p00k.c0jk = p00k.c0jk)
  
  res_batch <- bind_rows(res_batch,.id = "aggregation") %>% 
    gather(key = "entropy_type",value = "entropy",-aggregation) %>% na.omit()
  
  return(res_batch)
}
```


For the estimation of errors, we use 20 fold bootstrap resampling for each sample point. To speed up the calculation, we can compute the results for the different bootstraps on multiple cores (parallel). Therefore we need to enbed the entropy function in a respective framework: 
This function draws the particle bootstraps from the original population and calculates the entropy using the function above. 


```{r}
#  availableCores()
#  plan(multisession,workers = availableCores() -1)
# #
# # #entropies ungrouped ####
# batch_entropy.parallel <- function(MLA.sample,part.numbers){
#   idx <- sample(1:nrow(MLA.sample),size = part.numbers,replace = T)
#   pd <- MLA.sample[idx,]
#   entropy = batch.entropy.corr(pd,corr = F)
# #  return(entropy)
# }


# Entropies_grouped_uncorrected <-  map(part_dat_grouped, ~future_replicate(20,batch_entropy.parallel(MLA.sample = .x,part.numbers = 100000),future.seed = T,simplify = F))
# Entropies.agg_grouped_uncorrected <- Entropies_grouped_uncorrected %>% map(~bind_rows(.x,.id = "N")) %>% bind_rows(.id = "Sample") %>%
#   group_by(Sample,entropy_type,aggregation) %>%
#   summarise(mean_entropy = mean(entropy), sd_entropy = sd(entropy))
# save(Entropies.agg_grouped_uncorrected,file = "Entropies_grouped_uncorrected.RData")
# 
#  availableCores()
#  plan(multisession,workers = availableCores() -1)
# 
# batch_entropy.parallel <- function(sample_point,part.numbers,particle_data){
#   pd <- particle_data[[sample_point]]
#   idx <- sample(1:nrow(pd),size = part.numbers,replace = T)
#   pd <- pd[idx,]
#   entropy = batch.entropy.corr(pd,sample_point = sample_point,corr = T)
#   return(entropy)
# }
# 
# Entropies_grouped_corrected <-  map(sample_points, ~future_replicate(20,batch_entropy.parallel(sample_point = .x,part.numbers = 100000,particle_data = part_dat_grouped),future.seed = T,simplify = F))
# names(Entropies_grouped_corrected) <- sample_points
# Entropies.agg_grouped_corrected <- Entropies_grouped_corrected %>% map(~bind_rows(.x,.id = "N")) %>% bind_rows(.id = "Sample") %>%
#   group_by(Sample,entropy_type,aggregation) %>%
#   summarise(mean_entropy = mean(entropy), sd_entropy = sd(entropy))
# save(Entropies.agg_grouped_corrected,file = "Entropies_grouped_corrected.RData")

 load("Entropies_grouped_sample.RData")
 load("Entropies_grouped_massbalance.RData")

```




## Rescaling of the Entropy: 

The entropies above are rescaled to the number of particles calculated in one gram of material with the relation $H_N = H_1 + log(N)$

```{r}
Part.Entropies <- Entropies.agg_grouped_sample %>% filter(entropy_type %in% c("p00k","p0jk")) %>%
  right_join(num.res,by = "Sample") %>%
  mutate(mean_entropy = mean_entropy + log(particle.numbers)) %>%
  select(-particle.numbers)

Chem.Entropies <- Entropies.agg_grouped_sample %>% filter(!(entropy_type %in% c("p00k","p0jk")))

Entropies.agg_grouped_sample_1g <- bind_rows(Part.Entropies,Chem.Entropies) %>% arrange(Sample) %>%
  rename( type = entropy_type)

g <- ggplot(Entropies.agg_grouped_sample_1g,aes(x = Sample,y = mean_entropy, fill = type)) +
  geom_bar(stat = "identity") +
  facet_grid(.~aggregation) +
  theme_classic() +
  labs(x = "Sample Point", y = "entropy_value") +
  scale_fill_manual(values = entropy_colors)
print(g)

ggsave(filename = "entropy.batches_grouped_sample.png",device = "png",width = 30, height = 20, units = "cm")

Part.Entropies <- Entropies.agg_grouped_massbalance %>% filter(entropy_type %in% c("p00k","p0jk")) %>%
  right_join(num.res,by = "Sample") %>%
  mutate(mean_entropy = mean_entropy + log(particle.numbers)) %>%
  select(-particle.numbers)

Chem.Entropies <- Entropies.agg_grouped_massbalance %>% filter(!(entropy_type %in% c("p00k","p0jk")))

Entropies.agg_grouped_massbalance_1g <- bind_rows(Part.Entropies,Chem.Entropies) %>% arrange(Sample) %>%
  rename( type = entropy_type)

Entropies.agg_grouped_massbalance_1g$type <- str_replace_all(Entropies.agg_grouped_massbalance_1g$type,c("c0j0" = "cij0","c0jk" = "cijk","p00k" = "pi0k","p0jk"="pijk"))

Entropies.agg_grouped_massbalance_1g$aggregation <- str_replace_all(Entropies.agg_grouped_massbalance_1g$aggregation,c("c0j0.p0jk" = "cij0.pijk","p00k.c0jk" = "pi0k.cijk"))

g <- ggplot(Entropies.agg_grouped_massbalance_1g,aes(x = Sample,y = mean_entropy, fill = type)) +
  geom_bar(stat = "identity") +
  facet_grid(.~aggregation) +
  theme_classic() +
labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"])) +
  scale_fill_manual(values = entropy_colors)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
print(g)

ggsave(filename = "entropy.batches.normalized_grouped_corrected.png",device = "png",width = 30, height = 20, units = "cm")
Entropies.agg_grouped_massbalance_1g

Entropies.agg_grouped_massbalance_1g
write.csv(Entropies.agg_grouped_massbalance_1g,file = "Entropie_batched_long_table.csv")
```

```{r plots for corrected calculations}
#plot for sieve
sieve_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$Sieve$product_stage)
sieve_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$Sieve$feed_stage)
sieve_data <- bind_rows(sieve_data_feed,sieve_data_product,.id = "stage")
sieve <- ggplot(sieve_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Sieve") +
  theme_classic()
plot(sieve)
ggsave(filename = "batch.entropies.sieve_massbalance.png",device = "png",width = 15, height = 12, units = "cm")

#plot for spiral classifier
spiral_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Spiral Con.`$product_stage)
spiral_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Spiral Con.`$feed_stage)
spiral_data <- bind_rows(spiral_data_feed,spiral_data_product,.id = "stage")
spiral <- ggplot(spiral_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Spiral Classifier") +
  theme_classic()
plot(spiral)

#plot for mill1
#plot for spiral classifier
mill1_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$Mill1$product_stage)
mill1_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$Mill1$feed_stage)
mill1_data <- bind_rows(mill1_data_feed,mill1_data_product,.id = "stage")
mill1 <- ggplot(mill1_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
   facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Mill1") +
  theme_classic()
plot(mill1)
ggsave(filename = "batch.entropies.mill1_massbalance.png",device = "png",width = 15, height = 12, units = "cm")

#plot for magnetic separation

mag_sep_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Magnetic Con.`$product_stage)
mag_sep_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Magnetic Con.`$feed_stage)
mag_sep_data <- bind_rows(mag_sep_data_feed,mag_sep_data_product,.id = "stage")
mag_sep <- ggplot(mag_sep_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Magnetic Separation") +
  theme_classic()
plot(mag_sep)
ggsave(filename = "batch.entropies.magneticseparator_massbalance.png",device = "png",width = 15, height = 12, units = "cm")

#plot for sulfide flotation

flotation_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Sulfide Flotation`$product_stage)
flotation_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Sulfide Flotation`$feed_stage)
flotation_data <- bind_rows(flotation_data_feed,flotation_data_product,.id = "stage")
flotation <- ggplot(flotation_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Sulfide Flotation") +
  theme_classic()
plot(flotation)

screw_class_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Screw Class.`$product_stage)
screw_class_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Screw Class.`$feed_stage)
screw_class_data <- bind_rows(screw_class_data_feed,screw_class_data_product,.id = "stage")
screw_class <- ggplot(screw_class_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Screw Classifier") +
  theme_classic()
plot(screw_class)

hydrocyclone_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$Hydrocyclone$product_stage)
hydrocyclone_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$Hydrocyclone$feed_stage)
hydrocyclone_data <- bind_rows(hydrocyclone_data_feed,hydrocyclone_data_product,.id = "stage")
hydrocyclone <- ggplot(hydrocyclone_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Hydrocyclone") +
  theme_classic()
plot(hydrocyclone)

shaking_table_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Shaking Table`$product_stage)
shaking_table_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$`Shaking Table`$feed_stage)
shaking_table_data <- bind_rows(shaking_table_data_feed,shaking_table_data_product,.id = "stage")
shaking_table <- ggplot(shaking_table_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Shaking Table") +
  theme_classic()
plot(shaking_table)
ggsave(filename = "batch.entropies.shaking_table.png",device = "png",width = 15, height = 12, units = "cm")

#mill2

mill2_data_product <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$Mill2$product_stage)
mill2_data_feed <- Entropies.agg_grouped_massbalance_1g %>% filter(Sample %in% machines$Mill2$feed_stage)
mill2_data <- bind_rows(mill2_data_feed,mill2_data_product,.id = "stage")
mill2 <- ggplot(mill2_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Mill2") +
  theme_classic()
plot(mill2)


plots = list(Sieve = sieve,
             Spiral_Classifier = spiral,
             Mill1 = mill1,
             Magnetic_Separator = mag_sep,
             Sulfide_Flotation = flotation,
             Screw_Classifier = screw_class,
             Hydrocyclone = hydrocyclone,
             Shaking_Table = shaking_table,
             Mill2 = mill2)

ggarrange(plotlist = plots,ncol = 3,nrow = 3,
          common.legend = T,
          legend = "right",
          hjust = c(-2,-0.4,-1),
          vjust = 0.5,
          heights = c(0.7,0.7,0.7),
         legend.grob = get_legend(plots),
          widths = c(1,1,1))

ggsave(filename = "batch.entropies_grouped_massbalance.png",device = "png",width = 30, height = 30, units = "cm")
```

```{r plots for corrected calculations}

#plot for sieve
sieve_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$Sieve$product_stage)
sieve_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$Sieve$feed_stage)
sieve_data <- bind_rows(sieve_data_feed,sieve_data_product,.id = "stage")
sieve <- ggplot(sieve_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Sieve") +
  theme_classic()
plot(sieve)

#plot for spiral classifier
spiral_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Spiral Con.`$product_stage)
spiral_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Spiral Con.`$feed_stage)
spiral_data <- bind_rows(spiral_data_feed,spiral_data_product,.id = "stage")
spiral <- ggplot(spiral_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Spiral Classifier") +
  theme_classic()
plot(spiral)

#plot for mill1
#plot for spiral classifier
mill1_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$Mill1$product_stage)
mill1_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$Mill1$feed_stage)
mill1_data <- bind_rows(mill1_data_feed,mill1_data_product,.id = "stage")
mill1 <- ggplot(mill1_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
   facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Mill1") +
  theme_classic()
plot(mill1)

#plot for magnetic separation

mag_sep_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Magnetic Con.`$product_stage)
mag_sep_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Magnetic Con.`$feed_stage)
mag_sep_data <- bind_rows(mag_sep_data_feed,mag_sep_data_product,.id = "stage")
mag_sep <- ggplot(mag_sep_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Magnetic Separation") +
  theme_classic()
plot(mag_sep)

#plot for sulfide flotation

flotation_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Sulfide Flotation`$product_stage)
flotation_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Sulfide Flotation`$feed_stage)
flotation_data <- bind_rows(flotation_data_feed,flotation_data_product,.id = "stage")
flotation <- ggplot(flotation_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Sulfide Flotation") +
  theme_classic()
plot(flotation)

screw_class_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Screw Class.`$product_stage)
screw_class_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Screw Class.`$feed_stage)
screw_class_data <- bind_rows(screw_class_data_feed,screw_class_data_product,.id = "stage")
screw_class <- ggplot(screw_class_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Screw Classifier") +
  theme_classic()
plot(screw_class)

hydrocyclone_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$Hydrocyclone$product_stage)
hydrocyclone_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$Hydrocyclone$feed_stage)
hydrocyclone_data <- bind_rows(hydrocyclone_data_feed,hydrocyclone_data_product,.id = "stage")
hydrocyclone <- ggplot(hydrocyclone_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Hydrocyclone") +
  theme_classic()
plot(hydrocyclone)

shaking_table_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Shaking Table`$product_stage)
shaking_table_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$`Shaking Table`$feed_stage)
shaking_table_data <- bind_rows(shaking_table_data_feed,shaking_table_data_product,.id = "stage")
shaking_table <- ggplot(shaking_table_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Shaking Table") +
  theme_classic()
plot(shaking_table)

#mill2

mill2_data_product <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$Mill2$product_stage)
mill2_data_feed <- Entropies.agg_grouped_uncorrected_1g %>% filter(Sample %in% machines$Mill2$feed_stage)
mill2_data <- bind_rows(mill2_data_feed,mill2_data_product,.id = "stage")
mill2 <- ggplot(mill2_data,aes(x = Sample, y = mean_entropy, fill = type )) +
  geom_bar(stat = "identity",position = "dodge") +
  geom_errorbar(aes(ymin=mean_entropy-sd_entropy, ymax=mean_entropy+sd_entropy), width=.2,
                 position=position_dodge(.9)) +
  facet_grid(type~stage,labeller = labeller(stage = c("1" = "Feed Stage","2" = "Product Stage")), scales = "free") +
  scale_fill_manual(values = entropy_colors) +
  labs(x = "Sample Point", y = expression(Delta~ ~s*"*"["i"]), title = "Mill2") +
  theme_classic()
plot(mill2)


plots = list(Sieve = sieve,
             Spiral_Classifier = spiral,
             Mill1 = mill1,
             Magnetic_Separator = mag_sep,
             Sulfide_Flotation = flotation,
             Screw_Classifier = screw_class,
             Hydrocyclone = hydrocyclone,
             Shaking_Table = shaking_table,
             Mill2 = mill2)

ggarrange(plotlist = plots,ncol = 2,nrow = 5,
          common.legend = T,
          legend = "right",
          hjust = c(-2,-0.4,-1),
          vjust = 0.5,
          heights = c(0.7,0.7,0.7),
         legend.grob = get_legend(plots),
          widths = c(1,1,1))

ggsave(filename = "batch.entropies_grouped_uncorrected.png",device = "png",width = 20, height = 50, units = "cm")
```

## Calculation of entropies for each machine in the pilot plant: 


```{r}

parallel.calculation <- function(samples,numbers,machine){
idx <- map2(samples,numbers,~sample(c(1:nrow(.x)),size = .y,replace = T))
boots <- map2(samples,idx,~.x[.y,])
boots_f <- boots[machine$feed_stage] %>% map(as.data.frame)
boots_p <- boots[machine$product_stage] %>% map(as.data.frame)
boots_f_recal <- list(bind_rows(boots_p))
pl <- length(machine$product_stage)
if(pl > 1){
entropy <- entropyforboots.corrected(boots_f,boots_p,weights = machine$weights,recal = T, con.mass.balance  = T,idx = idx)
}else{
entropy <- entropyforboots.corrected(boots_f,boots_p,weights = machine$weights, recal = F, con.mass.balance = T,idx = idx)
}
return(entropy)
}

machine.entropy <- function(machine,particle.numbers,total.number,replicates){
pl <- length(machine$product_stage)
p_n <- total.number
if(pl > 1){
phi_products = clo(particle.numbers[machine$product_stage]*machine$weights[machine$product_stage])
phi_feed <- clo(particle.numbers[machine$feed_stage]*machine$weights[machine$feed_stage])
phi <- c(phi_feed,phi_products)
}else{
phi = clo(particle.numbers[c(machine$feed_stage,machine$product_stage)]*machine$weights)
}
p_num <- phi*p_n
samples <- part_dat_grouped[c(machine$feed_stage,machine$product_stage)]
numbers <- p_num
availableCores()
plan(multisession,workers = availableCores() -1)
entropies <- parallel.calculation(samples = samples,numbers = p_num,machine = machine)
#entropies <-  future_replicate(replicates,parallel.calculation(samples = samples,numbers = p_num,machine = machine),future.seed = T,simplify = F)
# entropies_agg <- entropies %>% bind_rows(.id = "N") %>% group_by(stage,aggregation,entropy_type) %>%
#   summarise(mean_entropy = mean(entropy),sd_entropy = sd(entropy))
return(entropies)
}


test_1 <- machine.entropy(machines$Hydrocyclone,particle.numbers = particle.numbers,total.number = 10000,replicates = 20)
test_2 <- machine.entropy(machine = machines$Mill1,particle.numbers = particle.numbers,total.number = 10000,replicates = 20)


#entropies_agg %>% group_by(stage,aggregation) %>% summarise(entropy = sum(mean_entropy))

machine_entropies_sample <- map(machines,~machine.entropy(.x,particle.numbers = particle.numbers,total.number = 100000,replicates = 250)) 
save(machine_entropies_sample,file = "machine_entropies_sample.RData")
load("./machine_entropies_sample.RData")


machine_entropies_massbalance <- map(machines,~machine.entropy(.x,particle.numbers = particle.numbers,total.number = 100000,replicates = 250)) 
save(machine_entropies_massbalance,file = "machine_entropies_massbalance.RData")
load("./machine_entropies_massbalance.RData")

machine_entropies_notrecal_sample <-  map(machines,~machine.entropy(.x,particle.numbers = particle.numbers,total.number = 100000,replicates = 250)) 
save(machine_entropies_notrecal_sample,file = "machine_entropies_notrecal_sample.RData")
load("./machine_entropies_notrecal_sample.RData")

machine_entropies_notrecal_massbalance <-  map(machines,~machine.entropy(.x,particle.numbers = particle.numbers,total.number = 100000,replicates = 250)) 
save(machine_entropies_notrecal_massbalance,file = "machine_entropies_notrecal_massbalance.RData")
load("./machine_entropies_notrecal_massbalance.RData")

machine_entropies_sample <- map(machine_entropies_sample,transpose)
t_values_uncorr <- map(machine_entropies_sample,~.x$t_val)
machine_entropies_agg <- map(machine_entropies_sample,~.x$entropy)
machine_entropies_agg <- machine_entropies_agg %>% map(~bind_rows(.x,.id = "N")) %>% bind_rows(.id = "machine") %>% group_by(machine,stage,aggregation,entropy_type) %>% 
  summarise(mean_entropy = mean(entropy),sd_entropy = sd(entropy))

machine_entropies_agg. <- machine_entropies %>% bind_rows(.id = "machine") %>% filter(aggregation != "c0j0.tij0.pijk")

unrecal_massbalance <- map(machine_entropies_notrecal_massbalance,transpose)
t_values_uncorr <- map(unrecal_massbalance,~.x$t_val)
machine_entropies_agg <- map(unrecal_massbalance,~.x$entropy)
machine_entropies_agg <- machine_entropies_agg %>% map(~bind_rows(.x,.id = "N")) %>% bind_rows(.id = "machine") %>% group_by(machine,stage,aggregation,entropy_type) %>% 
  summarise(mean_entropy = mean(entropy),sd_entropy = sd(entropy))

machine_entropies_agg. <- machine_entropies %>% bind_rows(.id = "machine") %>% filter(aggregation != "c0j0.tij0.pijk")

g <- ggplot(machine_entropies_agg,aes(x = aggregation, y = mean_entropy, fill = entropy_type)) +
  geom_bar(stat = "identity") +
  facet_grid(machine~stage) +
  theme_bw() +
  scale_fill_manual(values = entropy_colors)
print(g)

feed_stage <- machine_entropies_agg %>% filter(stage == "feed")
product_stage <- machine_entropies_agg %>% filter(stage == "product")


entropy_differences <- right_join(feed_stage,product_stage,by = c("machine","aggregation","entropy_type")) %>% mutate(entropy_diff = mean_entropy.y-mean_entropy.x)

machine.nms <- c("Sieve"="Sieve","spiral Con."="Spiral Concentrator","Mill1"="Mill1","Magnetic Con."="Magnetic Separator","Sulfide Flotation"="Sulphide-Flotation","Screw Class."="Screw-Classifier","Hydrocyclone"="Hydro-Cyclone","Shaking Table"="Shaking-Table","Mill2"="Mill2")
machine.lvl.extended <- machine.nms
names(machine.lvl.extended) <-  NULL

g <- ggplot(entropy_differences,aes(x = entropy_type,y = entropy_diff)) +
  geom_bar(stat = "identity") +
  facet_wrap(vars(factor(machine,levels = machine_levels)))  +
  labs(x = "entropy contribution", y = "entropy difference") +
  theme_bw()
print(g)

ggsave(filename = "notrecal.massbalance.png",device = "png",width = 30, height = 20, units = "cm")

g <- ggplot(entropy_differences,aes(x = machine,y = entropy_diff)) +
  geom_bar(stat = "identity") +
  facet_grid(entropy_type~., scales = "free_y")  +
  labs(x = "entropy contribution", y = "entropy difference") +
  theme_bw()
print(g)


```


```{r processing machine entropies with recalculated feed and concentrations from massbalance}
machine_entropies_massbalance <- map(machine_entropies,transpose)
t_values_uncorr <- map(machine_entropies_massbalance,~.x$t_val)
machine_entropies_agg <- map(machine_entropies_massbalance,~.x$entropy)
machine_entropies_agg <- machine_entropies_agg %>% map(~bind_rows(.x,.id = "N")) %>% bind_rows(.id = "machine") %>% group_by(machine,stage,aggregation,entropy_type) %>% 
  summarise(mean_entropy = mean(entropy),sd_entropy = sd(entropy))

feed_stage <- machine_entropies_agg %>% filter(stage == "feed")
product_stage <- machine_entropies_agg %>% filter(stage == "product")


entropy_differences <- right_join(feed_stage,product_stage,by = c("machine","aggregation","entropy_type")) %>% mutate(entropy_diff = mean_entropy.y-mean_entropy.x)

machine.nms <- c("Sieve"="Sieve","spiral Con."="Spiral Concentrator","Mill1"="Mill1","Magnetic Con."="Magnetic Separator","Sulfide Flotation"="Sulphide-Flotation","Screw Class."="Screw-Classifier","Hydrocyclone"="Hydro-Cyclone","Shaking Table"="Shaking-Table","Mill2"="Mill2")
machine.lvl.extended <- machine.nms
names(machine.lvl.extended) <-  NULL

g <- ggplot(entropy_differences,aes(x = entropy_type,y = entropy_diff)) +
  geom_bar(stat = "identity") +
  facet_wrap(vars(factor(machine,levels = machine_levels)))  +
  labs(x = "entropy contribution", y = "entropy difference") +
  theme_bw()
print(g)

ggsave(filename = "notrecal.massbalance.png",device = "png",width = 30, height = 20, units = "cm")

g <- ggplot(entropy_differences,aes(x = factor(machine,levels = machine_levels),y = entropy_diff, fill = entropy_type)) +
  geom_bar(stat = "identity") +
  facet_grid(entropy_type~., scales = "free_y")  +
  labs(x = "entropy contribution", y = "entropy difference") +
  theme_bw() +
   scale_fill_manual(values = entropy_colors) +
  theme(axis.text.x=element_text(angle = -90, hjust = 0)) +
  guides(fill="none")
print(g)

ggsave(filename = "recal.massbalance.png",device = "png",width = 30, height = 20, units = "cm")
```


```{r calculating compositions for the batches}
sample_names <- row.names(grouped_concentrations)
mineralogy <- grouped_concentrations %>% mutate(sample = sample_names) %>%  gather(key = "Mineral",value = "Content",-sample)

machine_table <-  read_delim("Machines_MLA.csv", delim = ";", 
    escape_double = FALSE, locale = locale(decimal_mark = ",", 
        grouping_mark = "."), trim_ws = TRUE)
machine_table <- machine_table %>% select(machine,sample,stage)
mineralogy <- right_join(mineralogy,machine_table,by = "sample")
g <- ggplot(mineralogy,aes(x = sample,y = Content, fill = Mineral)) +
  geom_bar(stat = "identity") +
  facet_wrap(vars(machine), scales = "free_x") +
  labs(x = "sample point",y = "content in %") +
    scale_fill_brewer(type = "qual",palette = "Set2")
  print(g)
  
  #entropy test :
  conc <- grouped_concentrations/100
  with_rest <- apply(conc,1,.entropy)
  
  conc_without <- conc %>% select(-Rest)
  without_rest <- apply(conc_without,1,.entropy)
  
# sieve composition: 
  
  mineralogy_sieve <- mineralogy %>% filter(machine == "Sieve")

  min_sieve <- ggplot(mineralogy_sieve,aes(x = sample,y = Content, fill = Mineral)) +
  geom_bar(stat = "identity") +
  facet_wrap(vars(stage), scales = "free_x") +
  labs(x = "sample point",y = "content in %",title = "Sieve") +
    scale_fill_brewer(type = "qual",palette = "Set2") +
    theme_bw()+
      theme(text = element_text(size = 20))
  print(min_sieve)
  
    mineralogy_mill <- mineralogy %>% filter(machine == "Mill1")

  min_mill <- ggplot(mineralogy_mill,aes(x = sample,y = Content, fill = Mineral)) +
  geom_bar(stat = "identity") +
  facet_wrap(vars(stage), scales = "free_x") +
  labs(x = "sample point",y = "content in %",title = "Mill1") +
    scale_fill_brewer(type = "qual",palette = "Set2") +
    theme_bw()+
      theme(text = element_text(size = 20))
  print(min_mill)
  
  mineralogy_magsep <- mineralogy %>% filter(machine == "Magnetic Con.")
  
    min_magsep <- ggplot(mineralogy_magsep,aes(x = sample,y = Content, fill = Mineral)) +
  geom_bar(stat = "identity") +
  facet_wrap(vars(stage), scales = "free_x") +
  labs(x = "sample point",y = "content in %",title = "Magnetic Separator") +
    scale_fill_brewer(type = "qual",palette = "Set2") +
    theme_bw()+
    theme(text = element_text(size = 20))
  print(min_magsep)
  
  mineralogy_shakingtable <- mineralogy %>% filter(machine == "Shaking Table")
  
  min_shakingtable <- ggplot(mineralogy_shakingtable,aes(x = sample,y = Content, fill = Mineral)) +
  geom_bar(stat = "identity") +
  facet_wrap(vars(stage), scales = "free_x") +
  labs(x = "sample point",y = "content in %",title = "Shaking Table") +
    scale_fill_brewer(type = "qual",palette = "Set2") +
    theme_bw()+
    theme(text = element_text(size = 20))
  print(min_shakingtable)
  

  
  plots = list(Sieve = min_sieve,
             Mill1 = min_mill,
             Magnetic_Separator = min_magsep,
             Shaking_Table = min_shakingtable
             )
  
  ggarrange(plotlist = plots,ncol = 2,nrow = 2,
          common.legend = T,
          legend = "right",
          hjust = c(-2,-0.4,-1),
          vjust = 0.5,
          heights = c(0.7,0.7,0.7),
         legend.grob = get_legend(plots),
          widths = c(1,1,1))
  ggsave(filename = "batch.mineralogy.png",device = "png",width = 30, height = 20, units = "cm")
  
  
```

```{r particle size analysis}
dat <- vol_masses$S01
part_size_dist <- function(dat){
dat <- select(dat,ECD,mass_vol)
idx <- sample.int(nrow(dat),size = 100000,replace = T)    
res <- dat[idx,]
res <- res %>% 
   mutate(s.classes = cut(.$ECD,breaks = c(0,10,20,40,80,100,160,250,320,500,640,800,1000,1300,1800,2600),
                             labels = c("10","20","40","80","100","160","250","320","500","640","800","1000","1300","1800","2600"))) %>% 
  mutate(s.classes = as.numeric(as.character(s.classes))) %>% 
  group_by(s.classes) %>% summarise(mass = sum(mass_vol)) %>% mutate(mass = cumsum(clo(mass)))
return(res)
}

availableCores()
plan(multisession,workers = availableCores() -1)

sizes <- map(vol_masses,~future_replicate(20,part_size_dist(.x),simplify = F))

sizes$S01

sizes.agg <- sizes %>% map(~bind_rows(.x,.id = "N")) %>% bind_rows(.id = "sample") %>% right_join(machine_table,by = "sample") %>% group_by(machine,stage,sample,s.classes) %>% summarise(mean_mass = mean(mass)*100,sd_mass = sd(mass)*100)

g <- ggplot(sizes.agg,aes(x = s.classes, y = mean_mass,col = sample)) +
  geom_point() +
  geom_line() +
  facet_wrap(vars(machine)) +
  geom_errorbar(aes(ymin= mean_mass - sd_mass,ymax = mean_mass + sd_mass), width = 0.2,position = "dodge") +
  theme_bw() 
plot(g)

batch.machines <- c("Sieve","Mill1","Magnetic Con.","Shaking Table")

batch.sizes <- sizes.agg %>% filter(machine %in% batch.machines)
a <- expression(log10(x))
g <- ggplot(batch.sizes,aes(x = log10(s.classes), y = mean_mass,col = sample)) +
  geom_point() +
  geom_line() +
  facet_wrap(vars(factor(machine,levels = batch.machines))) +
  geom_errorbar(aes(ymin= mean_mass - sd_mass,ymax = mean_mass + sd_mass), width = 0.05) +
  theme_bw() +
  scale_color_brewer(type = "qual",palette = "Paired") +
  labs(y = expression(Q[3]~(x)),x = expression(paste(log[10]~(x)," in µm "))) +
  theme(text = element_text(size = 20))
plot(g)

ggsave(filename = "batch.size.dist.png",device = "png",width = 30, height = 20, units = "cm")
```

```{r}
library(RColorBrewer)
brewer.pal(n = 12,"Paired")
```

